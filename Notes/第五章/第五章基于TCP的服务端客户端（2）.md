# 第五章基于TCP的服务端/客户端（2）

**tips：若想在同一个数组中保存并传输多种数据类型，应把数组声明为char类型**

## TCP原理

### TCP套接字中的I/O缓冲

![image-20241231112625056](D:\Typora\Socket编程\第五章\TCP_IO_flush.png)

在TCP套接字进行数据传输中，write()调用后，将数据写入到输出缓冲区，并不是直接发送给目标主机的数据套接字；read()函数也一样，调用后是从输入缓冲区内读取数据；每个数据流套接字都会对应一个输入缓冲区和一个输出缓冲区；可以实现全双工通信。

****

**即使关闭套接字也会继续传递输出缓冲区中遗留的数据，而如果关闭了套接字将会丢失输入缓冲区的数据。**

****

**TCP有个滑动窗口协议，会控制数据流，不会因为缓冲溢出而丢失数据，例如输入缓冲区大小是50个字节，输出缓冲区大小是100个字节，当输入缓冲区收到的来自输出缓冲区的100个字节时，首先会read掉50个字节，剩余的数据会等待TCP的滑动窗口获取数据。总的来说TCP会保证对输出缓冲数据的传输。**

****

**tips：write函数和Windows的send函数并不会在完成向对方主机的数据传输时返回，而是在数据移到输出缓冲时。因为TCP会保证对输出缓冲数据的传输，所以说write函数在数据传输完成时返回。**

### TCP内部工作原理1：与对方套接字的连接

#### tcp套接字从创建到消失所经过程分为如下3步：

​		与对方套接字建立连接

​		与对方套接字进行数据交换

​		断开与对方套接字的连接

#### 三次握手

<img src="D:\Typora\Socket编程\第五章\three_way_handshaking.png" alt="image-20241231143148852" style="zoom:67%;" />

第一次握手：首先请求连接的主机A向主机B传递如下信息：

```tcl
[SYN] SEQ: 1000, ACK: -
//SEQ为1000的含义表明：“现传递的数据包序号为1000，如果接收无误，请通知我向您传递1001号数据包。”
这是首次请求连接时使用的消息，又称SYN(Synchronization)，表示收发数据前传输的同步消息。
```

第二次握手：主机B向主机A传递消息：

```tcl
[SYN+ACK] SEQ: 2000, ACK: 1001
//SEQ为2000的含义表明：“现在给你传递的数据包序号为2000，如果接收无误，请通知我向您传递2001的数据包”
//ACK为1001表示的是：“我已经收到你的序列号为1000的包，现在请传递序列号为1001的包给我吧！”
```

第三次握手：主机A向主机B传递消息：

```tcl
[SYN+ACK] SEQ: 1001, ACK: 2001
//SEQ为1001的含义表明：“现在给你传递的你要的序号为1001的数据包。”
//ACK为2001表示的是：“我已经收到你的序列号为2000的包，现在请传递序列号为2001的包给我吧！”
```

#### 与对方主机的数据交换

通过第一步三次握手完成了数据交换准备，便可以开始收发数据了。

<img src="D:\Typora\Socket编程\第五章\TCP_data_transmission.png" alt="image-20250101115847364" style="zoom:67%;" />

传输数据与建立连接相似，上图主机A分两次给主机B传输100个字节的数据：

主机A：

```tcl
**第一次传输100个字节数据**
SEQ: 1200 100 bytes data
//发送的数据包序号为1200，且传输了100个字节
```

主机B：

```tcl
ACK: 1301
//表示我已经收到了序号为1200的数据包以及100个字节的数据，现在请你给我传递序号为1301（1200+100+1）的数据包。其目的是ACK号的增量为传输的数据字节数。假设每次ACK号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100个字节全都正确传递还是丢失了一部分。
//传递ACK消息的公式为：ACK号 —> SEQ + 传递的字节数 + 1
```

主机A：

```tcl
**第一次传输100个字节数据**
SEQ: 1301 100 bytes data
//发送的数据包序号为1301，且传输了100个字节
```

主机B：

```tcl
ACK: 1402
//表示我已经收到了序号为1301的数据包以及100个字节的数据，现在请你给我传递序号为1402（1301+100+1）的数据包。
```

至此，两次传输的流程已结束。

#### 断开与套接字的连接

TCP的断开连接对应了**四次握手过程**，因为要确保数据传输的完整性。断开连接时双方对话如下：
<img src="D:\Typora\Socket编程\第五章\TCP_disconnect.png" alt="image-20250101122701608" style="zoom:67%;" />

断开连接的流程图如下：

<img src="C:\Users\Jackie Feng\AppData\Roaming\Typora\typora-user-images\image-20250101123804955.png" alt="image-20250101123804955" style="zoom:67%;" />

传输的消息数据包内的FIN表示断开连接。也就是说，双方各发送一次FIN消息后断开连接。此过程经历了四个阶段，因此又称四次握手。

#### 第五章第二小节习题：

##### 1、请说明TCP套接字连接设置的三次握手过程。尤其是3次数据交换过程每次收发的数据内容。

答：1、第一次握手：客户端给服务端发送一个序号数据包SYN：（SEQ：1000，ACK：—），其中SEQ为1000表示通知服务端：客户端我给你发送了个序列号为1000的消息数据包，如确认收到，请你通知我给你发送序列号为1001的消息数据包。

​		2、第二次握手：服务端接收到客户端给他发送的序列号为1000的数据包后，给客户端发送一个SYN+ACK的消息数据包，例如（SEQ：2000， ACK：1001），其中SEQ：2000表示服务端给客户端发送了个序列号为2000的消息数据包，如果客户端收发无误，请客户端要求服务端给自己发送序列号为2001的数据包；ACK：1001表示服务端已经收到客户端发送的序列号为1000的数据包，现在请求客户端发送序列号为1001的数据包。

​		3、第三次握手：客户端给服务端发送一个SYN+ACK的消息数据包，例如（SEQ：1001， ACK：2001），其中SEQ：1001表示客户端给服务端发送了个序列号为1001的消息数据包，如果服务端收发无误，请服务端要求自己给它发送序列号为1002的数据包；ACK：2001表示客户端已经收到服务端发送的序列号为2000的数据包，现在请求服务端给自己发送序列号为2001的数据包。

##### 2、TCP是可靠的数据传输协议，但在通过网络通信的过程中可能会丢失数据。请通过ACK和SEQ说明TCP通过何种机制保证丢失数据的可靠传输。

答：<img src="C:\Users\Jackie Feng\AppData\Roaming\Typora\typora-user-images\image-20250102113324469.png" alt="image-20250102113324469" style="zoom:67%;" />

如上图所示，类似于建立连接过程相似，发送端主机A给目标主机B发送seq数据消息包，例如序列号为1200，然后再传输100个字节。主机B成功收到了序列号为1200的消息包和100个字节数据后，发送个ACK号为1301（这里的1301是1200+100+1）给主机A，意思是告诉主机A数据已经收到，你接下来可以发送序列号为1301的数据包给我了。这样不断的收发，保证数据有效的传输。当主机B收到的数据丢失时，发送回的ACK号会被主机A检查到，并对丢失的数据进行重发。

##### 3、TCP套接字中调用write和read函数时数据如何移动？结合I/O缓冲进行说明。

答：write和read函数时应用程序与TCP协议栈之间的接口。write将数据从用户空间复制到内核空间的发送缓冲区，read将数据从接收缓冲区复制到用户空间。TCP协议栈负责在后台进行数据的实际发送和接收，并处理流量控制、拥塞控制等复杂网络传输问题。

##### 4、对方主机的输入缓冲剩余50字节空间时，若本方主机通过write函数请求70字节，请问TCP如何处理这种情况？

答：当对方主机的输入缓冲（接收缓冲区）剩余50个字节空间，而本方主机通过write函数请求发送70字节的数据时，TCP会根据其流量控制机制进行处理。

​		TCP的流量控制：TCP使用滑动窗口机制进行流量控制，以防止发送方数据的速度超过接收方的处理能力。接收方会通过TCP报文段的头部中的“窗口大小”字段通告自己的接收窗口大小（即接收缓冲区剩余空间）。

​		TCP通过滑动窗口机制确保发送方不会发送超过接收方处理能力的数据。当write尝试发送的数据量超过对方的接收窗口大小时：

​		**阻塞模式：**write会阻塞，直到对方的接收窗口有足够的空间。

​		**非阻塞模式：**write会立即返回，并返回实际写入的字节数（可能小于请求的字节数）或错误码。

​		发送方TCP会根据接收方通告的窗口大小调整自己的发送窗口，并分批发送数据。
